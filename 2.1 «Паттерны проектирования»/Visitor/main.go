package main

import "fmt"

type Transport interface {
	Accept()
}

type Visitor interface {
	VisitCar(*Car)
	VisitAirplane(*Airplane)
}

// Базовая структура для транспорта с общими полями
type BaseTransport struct {
	Distance   int
	Passengers int
	CostPerKM  int
}

// Структура для автомобиля, наследует BaseTransport
type Car struct {
	BaseTransport
}

func (c *Car) Accept(v Visitor) {
	v.VisitCar(c)
}

// Структура для самолета, наследует BaseTransport
type Airplane struct {
	BaseTransport
}

func (a *Airplane) Accept(v Visitor) {
	v.VisitAirplane(a)
}

type CostCalculator struct {
	TotalCost int
}

func (cc *CostCalculator) VisitCar(c *Car) {
	cc.TotalCost = c.Passengers * c.Distance * c.CostPerKM
}

func (cc *CostCalculator) VisitAirplane(a *Airplane) {
	cc.TotalCost = a.Passengers * a.Distance * a.CostPerKM
}

func main() {
	car := &Car{
		BaseTransport{
			Distance:   30,
			Passengers: 4,
			CostPerKM:  100,
		},
	}

	airplane := &Airplane{
		BaseTransport{
			Distance:   30,
			Passengers: 4,
			CostPerKM:  100,
		},
	}

	costCalculator := &CostCalculator{}

	car.Accept(costCalculator)
	fmt.Println("Car cost: ", costCalculator.TotalCost)

	airplane.Accept(costCalculator)
	fmt.Println("Airplane cost:", costCalculator.TotalCost)
}

// Паттерн "Посетитель" позволяет применять одну и ту же операцию к объектам различных
// типов (интерфейсов) в Go, не изменяя сами эти типы.
// Паттерн "Посетитель" позволяет извлечь рутинные операции из
// самих типов (которые могут быть сложной структурой, такой как дерево),
// поместив их в отдельные типы, реализующие интерфейсы визиторов.
// Это позволяет сосредоточить логику операций в одном месте и не изменять типы объектов.

// Плюсы применения паттерна "Посетитель":
// 1. Упрощает добавление операций, работающих со сложными структурами объектов.
//    Паттерн позволяет добавлять новые операции для различных типов структур, не изменяя сами эти структуры.
//    Новые операции могут быть добавлены путем реализации методов интерфейса визитора, что упрощает расширяемость кода.

// 2. Объединяет родственные операции в одном типе (визиторе).
//    Паттерн позволяет сгруппировать все операции для различных типов структур в одном типе (внутри одного визитора),
//    что помогает избежать дублирования кода и делает его более читаемым и организованным.

// 3. Визиторы могут накапливать состояние при обходе структуры объектов.
//    Паттерн позволяет визитору сохранять состояние в процессе обхода структуры объектов,

// Минусы применения паттерна "Посетитель":
// 1. Паттерн не оправдан, если иерархия элементов часто меняется.
//    Если структура объектов часто изменяется (добавление или удаление новых типов),
//    то каждый раз необходимо изменять и визитора, добавляя новые методы для работы с новыми типами,
//    что может привести к значительным затратам на поддержку кода и сделать его сложным для расширения.

// 2. Может привести к нарушению инкапсуляции элементов.
//    Паттерн "Посетитель" позволяет визитору напрямую обращаться к внутренним данным элементов,
//    что может нарушить принцип инкапсуляции. Например, визитор может изменять внутренние данные структур,
//    что обычно должно быть скрыто от внешнего мира. Это может привести к зависимости между визитором и элементами.
