package main

import "fmt"

// UserState интерфейс для состояний пользователя
type UserState interface {
	Login() string
	Logout() string
}

// Guest состояние для гостя
type Guest struct{}

func (g *Guest) Login() string {
	return "Guest logged in"
}

func (g *Guest) Logout() string {
	return "Guest cannot logout"
}

// User состояние для вошедшего пользователя
type User struct{}

func (u *User) Login() string {
	return "User is already logged in"
}

func (u *User) Logout() string {
	return "User logged out"
}

type UserStatus struct {
	state UserState
}

func NewUserStatus() *UserStatus {
	return &UserStatus{state: &Guest{}}
}

func (us *UserStatus) SetStatus(state UserState) {
	us.state = state
}

func (us *UserStatus) Login() string {
	return us.state.Login()
}

func (us *UserStatus) Logout() string {
	return us.state.Logout()
}

func main() {
	user := NewUserStatus()

	fmt.Println(user.Login())

	user.SetStatus(&User{})

	fmt.Println(user.Login())
	fmt.Println(user.Logout())
}

// Паттерн "Состояние" позволяет отделить код, отвечающий за поведение объекта,
// от самого объекта. Этот паттерн подходит для случаев, когда поведение
// объекта меняется в зависимости от его внутреннего состояния, и таких
// состояний может быть много. Вместо того чтобы использовать большие условные
// операторы, каждое состояние представляется отдельной структурой, содержащей
// все поля и методы, связанные с ним.
//
// Основной объект (контекст) будет постоянно ссылаться на одно из
// состояний, делегируя ему выполнение определённых действий. Чтобы изменить
// поведение объекта, достаточно заменить объект-состояние на другой.
//
// Плюсы применения паттерна "Состояние":
// 1. Убирает множество больших условных операторов.
//    Логика переключения состояний сосредоточена в отдельных структурах,
//    что упрощает чтение и поддержку кода.
//
// 2. Концентрирует в одном месте код, связанный с определённым состоянием.
//    Каждое состояние инкапсулирует своё поведение, что упрощает понимание
//    логики программы и облегчает её изменение.
//
// Минусы применения паттерна "Состояние":
// 1. Может усложнить код в случае малочисленных и редко изменяющихся состояний.
//    Если состояний не так много, использование этого паттерна может
//    привести к излишней абстракции и усложнению программы.
//
// 2. Нужда в создании отдельных структур для каждого состояния.
//    Для каждого нового состояния потребуется создать отдельную структуру,
//    что увеличивает количество кода и может усложнить структуру программы.
